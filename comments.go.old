/*
	This revision of comments took a slightly different approach.
	anschelsc's original code had dealt exclusively with single-character
	comments, and thus the code was shorter and faster. This revision
	attempts to maintain that speed by deliniating between character-
	and string-based readers.  The result is much messier, uglier code,
	but code that may run slightly faster (although a quick review
	of the inner loops will demonstrate that such a gain is minimal).
*/

package comments

import (
	"io"
)

const (
	defaultstart byte = '#'
	defaultstop  byte = '\n'
)

type stringReader struct {
	r io.Reader
	stringState
	start []byte
	stop  []byte
}

type charReader struct {
	r io.Reader
	charState
	start byte
	stop  byte
}

// NewReader returns an io.Reader which copies directly from r, ignoring '#' and
// any characters following it on the same line.
func NewReader(r io.Reader) io.Reader {
	return &charReader{r, charText, defaultstart, defaultstop}
}

// NewCustomReader is identical to NewReader, except that it accepts custom
// start and stop delimeters
func NewCustomReader(r io.Reader, start, stop string) io.Reader {
	if len(start) == 1 && len(stop) == 1 {
		return &charReader{r, charText, start[0], stop[0]}
	}
	return &stringReader{r, stringText, []byte(start), []byte(stop)}
}

func (r *charReader) Read(buf []byte) (int, error) {
	n, err := r.r.Read(buf)
	buf = buf[:n]
	var wcount, rcount int
	for rcount != len(buf) {
		var written, read int
		_ = buf[rcount:]
		_ = buf[wcount:]
		written, read, r.charState = r.charState(buf[wcount:], buf[rcount:], r.start, r.stop)
		wcount += written
		rcount += read
	}
	return wcount, err
}

func (r *stringReader) Read(buf []byte) (int, error) {
	n, err := r.r.Read(buf)
	buf = buf[:n]
	var wcount, rcount int
	for rcount != len(buf) {
		var written, read int
		_ = buf[rcount:]
		_ = buf[wcount:]
		written, read, r.stringState = r.stringState(buf[wcount:], buf[rcount:], r.start, r.stop)
		wcount += written
		rcount += read
	}
	return wcount, err
}

type charState func(dst, src []byte, start, stop byte) (written, read int, next charState)

func charText(dst, src []byte, start, stop byte) (written, read int, next charState) {
	for i, b := range src {
		if b == start {
			return i, i + 1, charComment
		}
		dst[i] = b
	}
	return len(src), len(src), charText
}

func charComment(dst, src []byte, start, stop byte) (written, read int, next charState) {
	for i, b := range src {
		if b == stop {
			return 0, i + 1, charText
		}
	}
	return 0, len(src), charComment
}

type stringState func(dst, src []byte, start, stop []byte) (written, read int, next stringState)

func stringText(dst, src []byte, start, stop []byte) (written, read int, next stringState) {
	dLen := len(start)
	sLen := len(src)
CHECK:
	for i, b := range src {
		if b == start[0] && dLen <= sLen-i {
			for j := 1; j < dLen; j++ {
				if src[i+j] != start[j] {
					continue CHECK
				}
			}
			return i, i + dLen, stringComment
		}
		dst[i] = b
	}
	return sLen, sLen, stringText
}

func stringComment(dst, src []byte, start, stop []byte) (written, read int, next stringState) {
	dLen := len(stop)
	sLen := len(src)
CHECK:
	for i, b := range src {
		if b == stop[0] && dLen <= sLen-i {
			for j := 1; j < dLen; j++ {
				if src[i+j] != stop[j] {
					continue CHECK
				}
			}
			return 0, i + dLen, stringText
		}
	}
	return 0, sLen, stringComment
}
